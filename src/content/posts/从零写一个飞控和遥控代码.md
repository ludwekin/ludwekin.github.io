---
title: 从零写一个飞控和遥控代码
date: 2025-12-08T08:49:57.000Z
tags:
    - 四旋翼
    - 飞控
    - 遥控
published: 2025-12-10T12:39:06.000Z
category: 四旋翼
slug: 从零写一个飞控和遥控代码
---


首先规定，飞控就是四旋翼的飞行控制器。

遥控就是遥控器。发射命令给四旋翼，来决定飞机上升速度，前进速度等。

四旋翼最关键也最容易的就这俩。别的没了。

你问我这样飞机就能飞了吗？差了电调和电机电池啥的，但是那些基本都是飞控和遥控器配置完之后才考虑的事情了。

macOS开发，下载cubeMX和cubeIDE。

然后想清楚最核心的逻辑，我希望四旋翼可以听我的指令，首先可以起飞，然后前进后退，那么遥控器的左边的摇杆和右边的摇杆要控制什么呢？我之前想了很久，后来我的答案是分情况。

不同四旋翼开源项目的飞行器控制逻辑都有区别，比如最简单的，你可以希望右边摇杆左右滑动控制飞行器左飞行和右飞行但是恒速度，也可以规定，摇杆幅度越大侧倾越大，从而速度越大。所以看你。


对于我和这个项目来说，我希望右摇杆左右拖动决定的是飞行器相对于稳定状态下的侧倾角度变化。这句话不完善，稍后我来清晰表达。

代码怎么实现呢？当你推动右摇杆时，我实际上是在请求一个特定的角度，飞控的 PID 控制器会计算所需的电机输出，以使飞行器达到并保持那个角度。当摇杆回中时，期望角度为 0，飞控会将飞行器拉回水平状态。

再明确一下，我是请求侧倾的角度变化还是角速度变化？

如果我请求角速度变化，那我摇杆一直往右打，飞机倾转60度之后不就坠机了？

所以我请求角度。

那么飞控的PID最好帮我控制角度。

同时，右摇杆我想到了一定要自动回中的，还得带点死区。这个好理解吧。

具体到代码。遥控器输入决定期望角度，然后飞控通过 PID_ANGLE_GAIN 转换为期望角速度。为什么要转成期望角速度？

因为飞控内部通常需要分两层控制。角度 loop（外环）加上 角速度 loop（内环）。

先解释为什么不只用一个角度环。

风吹一下，角度 PID 无法快速抵消，只能等角度偏差出现再纠正，会来不及自稳。

具体验证需要通过实践，后面我会实际验证给读者看。

多提一嘴，为什么DJI的四旋翼这么稳？我估计DJI的角速度 PID loop 肯定很高。

思维扩散。思考一个问题，四旋翼的电机，电机的工作，到底会改变四旋翼的什么？

一是飞机的三维“角速度”（旋转速度）。二是“角度”，但是角度是经过时间积分产生的。θ(t)=∫ω(t)dt。

再补充一下，就刚才的右摇杆左右拖动决定的是飞行器相对于稳定状态下的侧倾角度变化，这个不绝对！

Betaflight用的就不是这个逻辑！

穿越机 FPV 的标准模式：摇杆控制的是 期望角速度（Desired Angular Velocity）。

算了都讲到这里了，直接补充Betaflight的Rate PID 控制器逻辑吧。

P_output = P_gain * error，I_term += I_gain * error * dt
，D_output = D_gain * (error - previous_error) / dt。

P决定打杆时的跟随感。
I作用是抵消风。
D是为了抑制 overshoot。

同时PID加在一起的PID_output是有限制幅度的，数值太大，电机受不了/电调受不了/电池受不了，四旋翼肯定就不稳定出事故了。

这里提几个难点吧。Betaflight 对 D 项做了 动态低通滤波，减少噪声导致的振荡。这个大后期再讲解。Betaflight 里面的 I 项还有 anti-windup 和 I-term relax（松杆时不积累）。

扯到Betaflight就太多太多可以说的了。

换到另外一个贴文里面讲解。文件命名是“Betaflight控制逻辑.md”。


SPI1：我假设SPI1用于BMI270和SX1281。

I2C1：我假设I2C1用于BMM150。

定时器TIM3：我假设TIM3的四个通道用于DShot输出。

GPIO引脚：我为BMI270的CS引脚、SX1281的CS/RESET/BUSY引脚假设了具体的GPIO端口和引脚号。

BMI270_CS_Pin (PA4)。

SX1281_CS_Pin (PB2)。

SX1281_RESET_Pin (PB10)。

将SX1281_BUSY_Pin (PB11) 配置为输入模式。

将TIM3的PWM输出引脚配置为复用推挽输出。等等，Why？

SX1281通常会有一个中断引脚（IRQ），当接收到有效数据包时会触发。需要在STM32中配置这个GPIO引脚为外部中断，并在中断服务函数中处理数据。

FlightController_Loop() 会调用 FC_ControlLoop()，后者会根据飞行控制器的计算结果，通过 DShot_SetThrottle(i, (uint16_t)motor_outputs[i]); 将油门值发送给对应的电调。

电池电压检测功能，我的飞控AIO硬件上是11.1V，输入后，通过dcdc降压到5v。然后ldo降压到3.3v。

ADC1的通道0 (PA0) 被启用并配置为常规通道。









