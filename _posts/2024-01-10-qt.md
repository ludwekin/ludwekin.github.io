---
title : "QT学习笔记"

published : false

---


## QT的使用场景？

1. QT，在嵌入式设备常用？arm芯片的开发板，加上屏幕的话，很多图形就是QT开发的？这是我看一个QT教程视频说的。然后还有些手机应用的图形界面，汽车中控屏的图形界面，PC的应用程序界面，都是QT开发的例子。




## 我的 Qt 学习之路：从模仿到改造

---

### 阶段一：模仿 —— 从官方示例开始

- 使用 Qt Creator 打开官方示例。  
- 了解 `.h` 和 `.cpp` 文件的分工：声明 vs 实现。  
- 熟悉 **信号与槽**，能让按钮和界面交互。  

---

### 阶段二：改造 —— 让示例变得复杂
- 在原有示例上 加入更多功能。
- 尝试改造界面布局，让窗口更美观。
- 尝试用 Qt Designer 或 QML 写界面，再与 C++ 逻辑结合。

---

### 阶段三：创造 —— 从零开始做自己的小项目
    - 结合我的现实经历和业务需求，为自己的项目写现代化界面。
	- 把 数据、逻辑、界面分层。
	- 尝试 CMake 管理项目，学习资源系统（.qrc）。

---

## 我遇到的问题/知识点，杂碎汇总

1. qt quick项目里面的 column是什么？

在 Qt Quick (QML) 里面，Column 是一个布局容器 (layout element)，它会把它的子元素按照 垂直方向 (vertical) 依次排列。
2. QT design studio是什么？

Qt Design Studio 是 Qt 公司推出的专业 UI 设计工具，主要用来 快速创建和编辑基于 Qt Quick (QML) 的用户界面。主要功能：可视化界面设计 → 拖拽控件、布局，不用手写 QML 就能生成 UI。
3. figma谁使用比较多？

    - UI/UX 设计师是核心用户，天天用 Figma 画界面。他们用它来设计 App、网站、桌面软件的界面。
    - 前端/客户端开发工程师用的多。
4. Qt Design Studio 可以用来 图形化设计 quick 项目的ui。
5. QT 现在和Qt Maintenance Tool绑定了，想下载QT必须要下载这个工具。然后后续想要增加组件/卸载QT，也需要通过这个工具来管理。
6. CMake 一般都要配合 ninja 一起使用的原因？

    - CMake 是一个构建系统生成器。没有编译的功能。它会在项目里面生成一个 CMakeLists.txt 文件，里面说明了“我要编译什么源文件，需要那些库”。
    - 而 ninja 才是真正实施编译的工具。
    - CMake 是2000年创造的。是为了解决 跨平台大型项目 的构建问题。
7. 补一下Makefile的历史/知识。
    - Makefile 是 Make 工具配套的。
    - Makefile 的存在是为了方便 用户快速编译/链接。
8. Make 工具。

    - 贝尔实验室的 Feldman 发明了 Make 工具。
    - 开发者需要 写一个规则文件（Makefile）来让 Make 运行。
9. POSIX是什么？

    - 全称是“Portable Operating System Interface”。
    - IEEE 制定的。
10. ninja 的历史。
    
    - Ninja 由 Google 工程师 Evan Martin 开发。
    - 当时 Google 在开发 Chromium / Chrome 浏览器，项目非常大，使用 GNU Make 构建时速度很慢，尤其是在增量编译（只修改一个文件后重新编译）时，等待时间过长。
    - 于是 Martin 设计了一个极简、高效的构建系统，目标就是——只做构建调度，不做复杂逻辑。
    - Ninja 是一个小而快的工具，核心代码量很少（几千行 C++）。
11. QT里面widget和mainwindow区别？

    - QWidget 是所有界面元素的基类，比较通用。
    - QMainWindow 是专门为“应用主窗口”准备的，带有完整框架。
12. widget.cpp和widge.h区别？

    头文件只告诉别人“有什么”；cpp 文件告诉“怎么做”。
13. QT Creator 如何使用git?

    - 我的解决办法是在 编辑器 下方的编辑框添加 terminal 来自己写git命令。
14. PySide6 = 用 Python 来写 Qt 应用的工具。

13. qt的applicationFlow是什么思想？ApplicationFlow 并不是 Qt 的底层核心库（像 QObject、QWidget 那样），而是 Qt Design Studio / Qt Quick Ultralite 里的一种 应用流程建模思想。它的核心思想是：

    - 把应用看作 一系列页面 (Pages / Screens)。

    - 页面之间通过 状态机 或 流转关系 (Flow) 来连接。

    - 开发者不必手写所有的跳转逻辑，而是通过 可视化工具 定义应用的页面结构和跳转条件。

    - 最后，工具会自动生成对应的 QML/代码，让程序在运行时遵循这些流程。
14. 我一直有个问题，没有QT的话，单纯用 C/C++ 要怎么创建 GUI？就拿 Windows 平台举例吧。

    - 方法一，直接使用 Win32 API（最基础）。Windows 系统本身提供了 Win32 API（User32.dll, GDI32.dll 等），用它可以写 GUI 程序。
    - 方法二，使用 MFC (Microsoft Foundation Classes)。这是微软基于 Win32 API 封装的 C++ 类库。
    - 方法三。使用 跨平台 GUI 库。这些库本质上还是调用 Win32 API，但帮你做了封装。
    - 显然这个问题没有完全解答。后续还需要继续实操一下。
15. .qml 文件怎么理解？第一次看到我也有点懵了，因为感觉有点乱。

    - 它有点像，Web 前端里的 HTML + CSS + JavaScript。
    - 核心思想是声明式编程。
    - .qml 文件里可以写 JS 代码处理逻辑，比如按钮点击事件。

16. .ui.qml 文件又是什么？

    - .ui.qml 文件是 一种特殊的 QML 文件，由 Qt Design Studio 引入。
    - 纯 UI 组件，只包含界面定义，不应该写逻辑代码。
17. QT 和 C++ 的关系：
    - Qt 在 GUI 开发里采用了 前后端分离 的方式。
    - 简单应用：只用 QML/JS 就能搞定（动画、状态机、轻逻辑）。
    - 复杂应用：QML 负责显示，C++ 提供核心逻辑。
    - QML 层（前端 UI）
         - 用 .qml 文件快速搭建界面。
         - 可以写 JavaScript 逻辑（轻量交互）。
         - 更接近设计师 / UI 开发。
    - C++ 层（后端逻辑）
       - 处理复杂业务逻辑：算法、数据库、网络、多线程。
       - 提供高性能模块。
       - 通过 QObject 和信号槽机制暴露给 QML。
18. mingw32编译器是什么？
    - MinGW 全称是 Minimalist GNU for Windows，意思是“Windows 平台上的简化版 GNU 工具集”。
    - 用来编译 C/C++，最后生成 原生 Windows 可执行文件 (.exe/.dll)。




--- 

## 杂七杂八

1. 想给MacBook也装上espanso，结果排查好久问题才发现这个插件不支持中文。





## hands on 

点击按钮，选择图片并显示




程序启动时，QApplication app(argc, argv); app.exec(); 会进入事件循环。

C++ 本身没有 运行时反射，也不知道函数名字、信号槽这些东西。
Qt 为了支持 信号槽机制、Q_OBJECT 宏、元对象反射，必须在编译阶段生成一堆额外代码。


QFileDialog 是 Qt 的 文件选择器控件。


在 C++ 里，:: 表示“某个名字属于谁”。

    - 左边 → 类名 / 命名空间名
	- 右边 → 这个类/命名空间里的成员


tr() 是什么？
在 Qt 中，tr() 是一个 国际化（i18n）翻译函数。
	•	它会把你写的字符串标记成“可翻译的文本”。
	•	Qt 的翻译工具（lupdate / linguist / lrelease）会自动扫描 tr("xxx")。
	•	然后根据不同语言的 .qm 文件，把字符串翻译成对应语言。




const和static区别？这是 C++ 的核心概念，容易混淆。

C++ 中 `const` 和 `static` 的区别对比表

| 特性            | `const`                                      | `static`                                        |
|-----------------|---------------------------------------------|------------------------------------------------|
| 修饰变量       | 值不能修改                                   | 生命周期延长到程序结束，或作用域受限             |
| 修饰函数参数    | 保证参数不会被改                             | ❌（不适用）                                    |
| 修饰成员函数    | 承诺函数不会修改对象成员                     | 表示这是类函数（不依赖对象）                    |
| 类的成员变量    | 每个对象一份，值固定                         | 所有对象共享一份                                |
| 文件作用域      | ❌                                           | 限定在当前 `.cpp` 文件可见，避免符号冲突        |



### Qt的元对象系统?

Qt 的元对象系统是 Qt 对 C++ 的扩展机制，用来实现 信号与槽（signal/slot）、运行时类型信息、动态属性、对象树等功能。
	•	C++ 本身没有内置的反射机制和信号/槽机制。
	•	Qt 用元对象系统实现了这些高级功能。

### Qt 控件的父子关系
在 Qt 中，每个控件都可以有一个 父控件。
父控件负责管理子控件的位置、大小，以及生命周期（自动删除子控件）。
例子：你有一个窗口 QMainWindow，里面有一个按钮 QPushButton，你可以把按钮的父控件设置为窗口，这样按钮就显示在窗口里。


### 栈和堆的区别（C++ 内存基础）

	•	堆（heap）
	•	程序员动态申请内存（new），需要手动释放（或者依赖 Qt 父子机制自动释放）
	•	优点：生命周期可控，适合 GUI 控件长期存在
	•	缺点：需要管理内存，否则会泄漏

    ```C++
    QWidget *w = new QWidget(); // 堆上对象
    w->show(); // w不会自动销毁，除非 delete w 或由父控件管理
    ```

    •	栈（stack）
	•	编译器自动管理内存，函数调用时分配，函数结束时自动释放。
	•	优点：速度快，不需要手动释放
	•	缺点：生命周期固定，超出作用域就销毁，不能动态扩展
    
    ```C++
    void func() {
    QWidget w; // 栈上对象
    // func结束，w被自动销毁
    } 
    ```