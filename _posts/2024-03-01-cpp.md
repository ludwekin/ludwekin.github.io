---

title : "C++ 个人学习笔记"

published : false
    

---






## C++ 的简述/发展史。

C++ 是由 Bjarne Stroustrup 在 1980 年代初在贝尔实验室发明的。

---

## 遇到的问题




1. C++ 项目里面为什么有 .h 文件又有 .cpp 文件？

    - .h 文件（头文件）
	    - 作用：声明（declare）。它里面通常包含 类的定义、函数声明、常量、宏 等。
	    - 目的：让别的文件知道「有哪些函数、类可以用」。
    - .cpp 文件（源文件）
	    - 作用：实现（implement）。它包含函数的具体实现代码。
	    - 目的：把逻辑写清楚，但不需要对外暴露细节。
    - 这不是所有编程语言都有的风格，而是 C++ 的一种传统编程风格，专业名字叫：“声明（Declaration）与实现（Implementation）分离” 风格。
        - 历史原因：C++ 是从 C 语言发展来的，而 C 在很早期（1970年代）就把 函数声明（告诉编译器这个函数存在） 和 函数实现（具体做什么）分开了。
        - 对比一下其他语言，Python / JavaScript 则更自由，直接写函数和类，不需要头文件。




## REST API 是什么？

REST 的概念是 由 Roy Fielding 在 2000 年他的博士论文中提出的。
	•	Roy Fielding 是计算机科学家，也是 HTTP 协议的主要设计者之一。
	•	他在论文中总结了 REST（Representational State Transfer） 的架构风格，用来指导 Web 系统的设计，让系统更简单、可扩展、易维护。
	•	REST 不是一个软件或具体产品，而是一种 设计原则。
	•	后来，开发者们基于 REST 原则，创建了 REST API，用于 Web 服务之间的数据交互。

### REST API 为什么能成为 Web 开发的主流标准？

1.	跨平台、跨语言
	•	前端网页、移动 App、IoT 设备都能调用 REST API
	•	不必使用同一种编程语言
2.	易于扩展和维护
	•	新资源可以独立增加，不破坏原有系统
	•	系统模块化更明显

1.	简单直观
	•	基于 HTTP 协议（GET/POST/PUT/DELETE）
	•	URL 对应资源，方法对应操作
	•	开发者容易理解和使用
2.	无状态（Stateless）
	•	每次请求都独立，服务器不保存客户端状态
	•	方便横向扩展（扩展服务器数量不影响客户端）

```cpp
class D : public B {
    ...
};
```

	•	public 关键字控制了继承的 访问级别 (access specifier)：
	•	public → B 的 public 成员在 D 中仍然是 public，B 的 protected 成员在 D 中是 protected。
	•	private 继承 → B 的 public 和 protected 成员在 D 中都变成 private。
	•	protected 继承 → B 的 public 和 protected 成员在 D 中都变成 protected。



用模板 vs 用运行时多态

模板写法（编译期决定）


```cpp
template<typename T>
T square(T x) {
    return x * x;
}

int main() {
    int a = square(3);        // 编译器生成 int 版本
    double b = square(2.5);   // 编译器生成 double 版本
}




```



编译器会生成两个函数：

```cpp

int square(int x) { return x * x; }
double square(double x) { return x * x; }



```



传统运行时多态写法（虚函数，运行时决定）


```cpp
struct Base {
    virtual double square(double x) = 0;
};

struct IntSquare : Base {
    double square(double x) override { return (int)x * (int)x; }
};

struct DoubleSquare : Base {
    double square(double x) override { return x * x; }
};

int main() {
    Base* p = new DoubleSquare();
    double result = p->square(2.5);  // 运行时通过 vtable 决定调用哪个函数
}

```


 ### STL 算法是什么？

 STL 算法的定义
	•	STL 算法 是一组 用模板写的函数，可以在不同的容器 (vector, list, map …) 上执行常见操作。
	•	它们不属于某个容器，而是 独立存在，通过 迭代器 (iterator) 来操作数据。


### 常见容器


“容器 (Container)” 属于 C++ 标准库 STL (Standard Template Library) 的核心部分。
在 C++ STL 里，容器是 类模板 (class template)，可以存放不同类型的对象。




容器的分类

(a) 序列式容器 (Sequence containers)

数据按顺序存放
	•	std::vector → 动态数组（最常用）
	•	std::list → 双向链表
	•	std::deque → 双端队列

(b) 关联式容器 (Associative containers)

数据按 键值 (key) 自动排序
	•	std::set → 不重复集合
	•	std::map → 键值对（类似 Python dict）
	•	std::multiset / std::multimap → 允许重复

(c) 无序容器 (Unordered containers)（基于哈希表）
	•	std::unordered_set
	•	std::unordered_map

(d) 容器适配器 (Container adapters)

把容器包装成特殊用途
	•	std::stack（栈，后进先出）
	•	std::queue（队列，先进先出）
	•	std::priority_queue（优先队列，最大/最小堆）





## 函数式编程是什么意思？


函数式编程 (Functional Programming, FP) 是一种编程思想：
	•	把 函数 当成“一等公民”（可以像变量一样传递、返回、组合）。
	•	强调 不可变性 (immutability) → 数据不会被修改，而是产生新数据。
	•	用 表达式 (expression) 而不是 语句 (statement)。
	•	代码更接近数学函数的形式。


```cpp

#include <algorithm>
#include <vector>
#include <iostream>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3, 4};

    // 使用函数式风格：用 lambda 作为参数
    for_each(v.begin(), v.end(), [](int x){ cout << x * x << " "; });
}

```

	•	[](int x){ cout << x * x << " "; }
	•	这是一个 lambda 表达式（匿名函数）
	•	[] → 捕获列表（这里没有捕获任何变量）
	•	(int x) → 参数列表
	•	{ cout << x * x << " "; } → 函数体，打印平方

	特点
	•	匿名：没有名字，直接写在需要的地方
	•	轻量：可以像变量一样传递给算法 (for_each, sort 等)
	•	闭包：能“捕获”外部变量（这就是 [] 的作用）


## c++怎么实现多线程？还有，为什么需要多线程？

为什么需要多线程？
	1.	提升性能
	•	多核 CPU → 同时运行多个任务
	•	例如：一个线程读文件，另一个线程计算数据
	2.	更好响应
	•	GUI 程序中：主线程保持界面流畅，后台线程执行耗时任务
	•	例如：下载器 → 一个线程下载，另一个线程更新进度条
	3.	并行处理
	•	大任务拆分成多个小任务，同时处理
	•	例如：科学计算、大规模数据处理、游戏物理引擎



C++11 引入了 <thread> 头文件，可以很方便地创建线程。


```cpp
#include <iostream>
#include <thread>
using namespace std;

int main() {
    thread t([](){
        cout << "Hello from another thread!" << endl;
    });

    t.join();
}

```


##  线程池是什么？为什么需要线程池？

**回答思路：**
- 线程池是一组预先创建好的线程，等待任务来执行。
- 避免频繁创建和销毁线程，减少开销。
- 控制并发线程数，防止系统过载。





1.	为什么要用 condition_variable？
•	避免线程空转，占用 CPU。
2.	如何安全地关闭线程池？
•	设置 stop 标志，通知所有线程退出。
3.	线程池中的任务执行顺序是怎样的？
•	通常是 FIFO（队列），也可根据优先级实现。




## 1️⃣ 如何实现动态线程池（线程数量可伸缩）？

**核心思路：**
- 维护一个线程池和任务队列。
- 根据任务队列长度和当前空闲线程数动态增加或减少线程。
- 保持线程池在一个合理范围内（最小线程数和最大线程数）。

**关键点：**
1. **增加线程**：
   - 当任务过多且空闲线程少时，创建新线程。
2. **减少线程**：
   - 当线程长时间空闲且总线程数超过最小值时，主动销毁部分线程。
3. **同步控制**：
   - 使用 `std::mutex` 和 `std::condition_variable` 避免竞争条件。
4. **线程安全的计数器**：
   - 跟踪空闲线程数和总线程数。

**示例伪代码：**
```cpp
void adjustThreadPool() {
    std::unique_lock<std::mutex> lock(mutex);
    if(tasks.size() > idleThreads && totalThreads < maxThreads) {
        // 增加线程
        workers.emplace_back([this]{ this->worker(); });
        totalThreads++;
    } else if(idleThreads > minThreads && totalThreads > minThreads) {
        // 线程空闲过多，可让部分线程退出
        stopExtraThreads();
    }
}
```


std::mutex 是互斥锁，用于保护共享资源，防止多个线程同时访问导致冲突。





在游戏服务器中，线程池主要用来**并发处理大量玩家请求**，避免每个请求都创建一个线程，因为创建/销毁线程开销大。

**场景示例：**
- 玩家发起移动、攻击、技能等操作
- 玩家请求存取数据库（排行榜、背包）
- 网络消息的收发

**线程池优势：**
- **固定数量线程**处理动态任务，节省资源
- **避免线程过多**导致 CPU/内存压力
- **支持异步任务**，提升响应速度

---

## 2️⃣ 线程池在游戏服务器中的典型结构

1. **任务队列（Task Queue）**
   - 网络模块解析玩家请求后，将任务封装成函数对象放入队列

2. **工作线程（Worker Thread）**
   - 从队列取任务执行
   - 可以复用线程，减少创建/销毁开销

3. **事件驱动**
   - 主线程负责监听网络事件
   - 将事件交给线程池处理

**伪代码示例：**

```cpp
void onPlayerRequest(NetworkMessage msg) {
    threadPool.enqueue([msg]() {
        // 处理玩家请求，例如更新位置、计算伤害
        processPlayerAction(msg);
    });
}
```

	1.	为什么不每个玩家开一个线程？
	•	成千上万玩家会导致线程数过多，消耗系统资源，降低效率
	2.	如何处理任务过多？
	•	可动态扩展线程池或任务排队，防止服务器崩溃
	3.	如何保证线程安全？
	•	使用 mutex 或其他同步原语保护共享数据（如玩家状态、地图信息）


为什么游戏服务器更喜欢二进制而不是 JSON？
	1.	实时性要求高
	•	UDP 数据包大小有限，频繁发送 JSON 可能丢包
	2.	性能要求高
	•	解析 JSON 需要字符串处理，CPU 消耗高
	3.	网络带宽有限
	•	大型 MMO、竞技游戏，每秒需要发送大量数据




Boost 库是一个为 C++ 语言开发的开源库集合，包含了许多功能强大、经过严格测试的模块，用于增强 C++ 的标准功能。它的目标是提供高质量、可复用的代码，让开发者在不依赖第三方闭源库的情况下，快速实现复杂功能。

主要特点:
1. **跨平台**：Boost 可以在大多数操作系统和编译器上使用。
2. **模块丰富**：包括智能指针（`boost::shared_ptr`）、线程（`boost::thread`）、正则表达式（`boost::regex`）、文件系统（`boost::filesystem`）等。
3. **与标准库兼容**：很多 Boost 库的功能后来被采纳进了 C++ 标准库，例如 `std::shared_ptr` 和 `std::filesystem` 就来源于 Boost。
4. **高质量和可移植性**：Boost 的库在设计时非常关注效率和跨平台的兼容性。

涉及的职业和研究者：
- **C++ 软件工程师**：尤其是需要高性能和跨平台开发的项目，如金融系统、游戏开发、嵌入式系统。
- **系统架构师**：设计大型系统时会用到 Boost 的高级工具。
- **学术研究者**：在需要高性能数值计算、图算法或并行计算的研究中，Boost 提供了很多现成工具。

总结：Boost 就像是 C++ 的“工具箱”，里面有许多标准库没有的工具，但可以帮助你更快、更安全地完成开发工作。




**Socket 通信**是计算机网络中一种基础通信机制，它可以让不同设备、不同进程之间交换数据。简单说，它就像是“电话线”或者“管道”，程序通过它可以发送和接收数据。

---



## socket通信，具体应用场景

1. **即时通信软件**
   - 微信、QQ、Slack 等聊天工具都是通过 socket 与服务器通信，实现消息的发送和接收。
   - 示例：你发消息 → 程序通过 socket 发送到服务器 → 服务器再转发给对方。

2. **网页与服务器通信**
   - HTTP/HTTPS 底层也是基于 TCP Socket。
   - 浏览网页、调用 API、下载文件都离不开 socket。

3. **网络游戏**
   - 网络游戏中的玩家位置、动作、状态更新都通过 socket 实时传输。
   - 例如 MMORPG 游戏中的角色移动同步。

4. **文件传输**
   - FTP、SFTP 或自建文件传输程序。
   - 可以实现远程上传、下载文件。

5. **物联网（IoT）设备**
   - 智能家居设备通过 socket 与云服务器通信，例如智能灯泡、智能摄像头。

6. **远程控制 / 远程桌面**
   - TeamViewer、AnyDesk、SSH 等工具使用 socket 实现远程操作。

7. **音视频直播**
   - Zoom、Bilibili直播、YouTube直播，都是通过 socket 实时传输音视频数据。




在网络游戏中，**Socket 通信**主要用于实现**实时同步**玩家的动作、位置和状态。具体来说：

---

### 1. 玩家位置同步

假设你在一个 MMORPG（大型多人在线角色扮演游戏）中：

- **客户端**：你移动角色，程序获取角色的新坐标 `(x, y, z)`。
- **发送**：客户端通过 Socket 将坐标数据发送到游戏服务器。
- **服务器**：接收所有玩家的数据，更新世界状态。
- **广播**：服务器通过 Socket 将你的新坐标发送给其他玩家的客户端。
- **其他客户端**：收到数据后，在屏幕上更新你的角色位置，实现“实时移动”。

---

### 2. 玩家动作同步

动作包括攻击、施法、跳跃、聊天等：

- 客户端检测到玩家动作，例如攻击技能 “Fireball”。
- 发送动作事件到服务器：`{playerID: 123, action: "Fireball", target: 456}`
- 服务器验证动作是否合法（是否冷却、是否命中目标）。
- 服务器广播给其他玩家客户端，其他玩家看到技能效果和动画。

---

### 3. 状态同步

包括玩家血量、魔法值、状态效果（如中毒、加速）：

- 玩家 A 被玩家 B 攻击：
  - 服务器计算伤害 → 更新玩家 A 的血量。
  - 服务器通过 Socket 通知玩家 A 和其他玩家新的血量和状态。
- 这样每个玩家看到的世界状态都是一致的。

---

### 技术要点

1. **实时性要求高**：位置和动作需要毫秒级更新，否则会出现“延迟、卡顿、瞬移”。
2. **数据压缩和优化**：发送的数据量要小，例如只传坐标增量，而不是全部数据。
3. **协议选择**：
   - **TCP Socket**：可靠，但有延迟，适合聊天、交易等不要求超低延迟的内容。
   - **UDP Socket**：不可靠，但速度快，适合玩家位置、动作等实时更新。
4. **预测和插值**：客户端可能会预测角色移动，平滑动画，减少网络延迟对游戏体验的影响。

---

### 职业相关

- **网络游戏开发工程师**：负责客户端与服务器的数据同步机制。
- **后端游戏服务器开发工程师**：设计高效稳定的 Socket 服务。
- **网络优化工程师**：降低延迟和数据包丢失，提高玩家体验。

总结：在网络游戏中，Socket 是“玩家和服务器之间的实时通信管道”，负责让每个人都能看到同一个世界、同样的动作和状态。



想从**原理验证到大型游戏级别的网络通信**，方法要更系统：不只是小实验，而是自己设计一个简化但完整的游戏网络架构来观察 TCP 和 UDP 的行为。下面给你一条可行路径。

---

### 1. 设计思路

#### 目标
- 创建一个**多人在线游戏原型**（2-20 个玩家即可）。
- 模拟角色移动、攻击、状态同步。
- 比较 TCP/UDP 在真实游戏环境下的表现。

#### 架构
1. **服务器**
   - 管理游戏状态（玩家位置、血量、动作）。
   - 负责广播更新给所有客户端。
   - 支持 TCP 和 UDP 两种传输模式切换。
2. **客户端**
   - 发送本地玩家动作到服务器。
   - 接收其他玩家数据，渲染游戏世界。
3. **数据结构**
   - **位置包**：`{playerID, x, y, z, timestamp}`。
   - **动作包**：`{playerID, action, targetID, timestamp}`。
   - **状态包**：`{playerID, HP, MP, statusFlags}`。

---

### 2. 验证方式

#### 实验设计
1. **小规模 UDP 实时同步**
   - 客户端频繁发送位置包（20~50ms 一次）。
   - 服务器广播给所有玩家。
   - 观察：
     - 是否有位置跳动（丢包）。
     - 动作顺序是否混乱。
2. **TCP 模式**
   - 使用 TCP 发送相同数据。
   - 观察：
     - 延迟变化。
     - 数据顺序是否严格。
3. **数据量与延迟测试**
   - 增加玩家数量，模拟高负载。
   - 测量网络延迟和丢包率。
4. **客户端预测机制**
   - 为 UDP 模式添加预测和插值算法。
   - 观察延迟对体验的影响。

---

### 3. 技术要点

1. **数据压缩**
   - UDP 尽量只发增量数据（位置差值）。
   - TCP 可以发完整状态，但注意带宽。
2. **时间戳**
   - 所有包带时间戳，方便客户端判断顺序和丢包。
3. **客户端平滑**
   - 对丢失的 UDP 包，客户端做插值或预测。
4. **网络模拟**
   - 使用工具（Linux `tc` 或 Windows 模拟器）增加延迟、丢包和抖动，验证 TCP/UDP 在各种网络环境下表现。

---

### 4. 可视化验证

- 在客户端画出**角色轨迹线**。
- 丢包或乱序会直接表现为：
  - 角色瞬移。
  - 动作显示错乱。
- 对比 TCP，轨迹平滑，但可能延迟高。

---

### 5. 职业相关

- **网络游戏开发工程师**：设计、测试和优化多人同步。
- **后端游戏服务器工程师**：处理高并发数据包。
- **实时系统工程师**：研究延迟、丢包处理算法。
- **游戏引擎开发者**：提供 UDP/TCP 网络 API 和预测机制。

---

总结：  
如果想从“原理验证”升级到“游戏级别验证”，核心是**搭建一个小型多人在线原型**，在 TCP 和 UDP 模式下测试玩家位置、动作、状态同步，观察延迟、丢包和顺序问题。这种方法最接近现实大型游戏的网络设计。